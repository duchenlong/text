#define _CRT_SECURE_NO_WARNINGS 1

//标题：九宫幻方
//
//小明最近在教邻居家的小朋友小学奥数，而最近正好讲述到了三阶幻方这个部分，三阶幻方指的是将1~9不重复的填入一个3 * 3的矩阵当中，使得每一行、每一列和每一条对角线的和都是相同的。
//
//三阶幻方又被称作九宫格，在小学奥数里有一句非常有名的口诀：“二四为肩，六八为足，左三右七，戴九履一，五居其中”，通过这样的一句口诀就能够非常完美的构造出一个九宫格来。
//
//4 9 2
//3 5 7
//8 1 6
//
//有意思的是，所有的三阶幻方，都可以通过这样一个九宫格进行若干镜像和旋转操作之后得到。现在小明准备将一个三阶幻方（不一定是上图中的那个）中的一些数抹掉，交给邻居家的小朋友来进行还原，并且希望她能够判断出究竟是不是只有一个解。
//
//而你呢，也被小明交付了同样的任务，但是不同的是，你需要写一个程序~
//
//输入格式：
//输入仅包含单组测试数据。
//每组测试数据为一个3 * 3的矩阵，其中为0的部分表示被小明抹去的部分。
//对于100%的数据，满足给出的矩阵至少能还原出一组可行的三阶幻方。
//
//输出格式：
//如果仅能还原出一组可行的三阶幻方，则将其输出，否则输出“Too Many”（不包含引号）。
//
//样例输入
//0 7 2
//0 5 0
//0 3 0
//
//样例输出
//6 7 2
//1 5 9
//8 3 4
//
//资源约定：
//峰值内存消耗（含虚拟机） < 256M
//CPU消耗  < 1000ms

#include<stdio.h>

int arr[10] = { 0 };
int a[10] = { 0 };
int add[10] = { 0 };
int sum = 0;
int ans = 0;

void slove()
{
	if (a[5] != 5)
	{
		return;
	}
	if (a[1] + a[2] + a[3] != a[4] + a[5] + a[6] || \
		a[1] + a[2] + a[3] != a[7] + a[8] + a[9])
	{
		return;
	}
	if (a[1] + a[4] + a[7] != a[2] + a[5] + a[8] || \
		a[1] + a[4] + a[7] != a[3] + a[6] + a[9])
	{
		return;
	}
	if (a[1] + a[9] != a[3] + a[7])
	{
		return;
	}
	for (int i = 0; i < 9; i++)
	{
		add[i + 1] = a[i + 1];
	}
	ans++;
}

void dfs(int index)
{
	if (ans>1)
	{
		return;
	}
	if (index == 10)
	{
		slove(); 
		return;
	}
	if (a[index])
	{
		dfs(index + 1);
	}
	else
	{
		int i = 1;
		for (i = 1; i < 10; i++)
		{
			if (!arr[i])
			{
				arr[i] = 1;
				a[index] = i;
				dfs(index + 1);
				arr[i] = 0;
				a[index] = 0;
			}
		}
	}
}

int main()
{
	int i = 0;
	int j = 0;
	for (i = 1; i< 10; i++)
	{
		scanf("%d", &a[i]);
		if (a[i] != 0)
		{
			arr[a[i]] = 1;
		}
	}
	dfs(1);
	if (ans == 1)
	{
		for (i = 1; i < 10; i++)
		{
			printf("%d ", add[i]);
			if (i % 3 == 0)
				printf("\n");
		}
	}
	else
	{
		printf("Too Many\n");
	}
	return 0;
}